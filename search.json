[{"title":"redis和rabbitmq中间件部署","date":"2023-06-20T03:22:57.000Z","url":"/2023/06/20/redis%E5%92%8Crabbitmq%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%83%A8%E7%BD%B2/","tags":[["最近给公司部署了一个uat环境，重新部署了一些中间件，中间发生了一些问题，写个笔记记录一下","/tags/%E6%9C%80%E8%BF%91%E7%BB%99%E5%85%AC%E5%8F%B8%E9%83%A8%E7%BD%B2%E4%BA%86%E4%B8%80%E4%B8%AAuat%E7%8E%AF%E5%A2%83%EF%BC%8C%E9%87%8D%E6%96%B0%E9%83%A8%E7%BD%B2%E4%BA%86%E4%B8%80%E4%BA%9B%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%8C%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%8C%E5%86%99%E4%B8%AA%E7%AC%94%E8%AE%B0%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B/"]],"categories":[[" ",""]],"content":" 上面出现了两个问题： 1.第一个redis设置默认密码，不然服务中去验证会失败，通过在最后追加 command: --requirepass &quot;123456&quot; 来设置密码 2.rabbitmq和我上面一样部署之后，需要进入到容器里面，安装插件具体操作步骤如下 "},{"title":"非常好用的github高级搜索","date":"2023-06-12T03:36:31.000Z","url":"/2023/06/12/%E9%9D%9E%E5%B8%B8%E5%A5%BD%E7%94%A8%E7%9A%84github%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2/","categories":[[" ",""]],"content":"高级搜索比如在github搜索，有谁在vue项目中使用blake3这个加密算法"},{"title":"健康提醒","date":"2023-06-05T02:48:08.000Z","url":"/2023/06/05/%E5%81%A5%E5%BA%B7%E6%8F%90%E9%86%92/","tags":[["crontab，notify-send","/tags/crontab%EF%BC%8Cnotify-send/"]],"categories":[[" ",""]],"content":"使用linux下自带的Crontab定时任务管理工具，以及第三方弹窗管理工具实现定时提醒功能安装notify-send 配置用户crontab脚本 安装和配置 效果"},{"title":"python爬虫妹子图","date":"2023-06-01T06:43:18.000Z","url":"/2023/06/01/python%E7%88%AC%E8%99%AB%E5%A6%B9%E5%AD%90%E5%9B%BE%EF%BC%88%E4%B8%8D%E4%BD%BF%E7%94%A8scrapy%E6%A1%86%E6%9E%B6%EF%BC%89/","tags":[["Python","/tags/Python/"]],"categories":[[" ",""]],"content":""},{"title":"Python基础","date":"2023-06-01T04:43:18.000Z","url":"/2023/06/01/python%E5%9F%BA%E7%A1%80/","tags":[["Python","/tags/Python/"]],"categories":[[" ",""]],"content":"基础知识点：1.dir(__ builtins __) 查询python的所有内置函数 1.列表为列表添加元素的三种方法：append()方法只有一个参数，参数内容是一个准备插入列表的元素extends()方法也只有一个参数，参数内容是一个准备合并入列表的一个列表类似于java的addAll();insert()方法有两个参数。第一个参数是准备插入的元素的索引值index，第二个参数是准备插入的元素，索引值从第0个开始元素交换位置：number[0],number[1]&#x3D;number[1],number[0]从列表删除元素的三种方式：remove()这个方法只有一个参数，参数内容就是list中要移除的元素的名字del 这个是个语句，不是list的方法 eg：del number[1] 这样就把下标为1的元素删除了 del number 直接删除整个listpop()这个是list的方法，可以带参数也可以不带参数，不带参数取出来的元素就是length-1的元素，带参数就是取对应下标的元素出来列表分片：number[start:end] 含头不含尾 只写start就从start到尾，只写end就从头到end位置，如果两个都不写，那么久拷贝原list number2 &#x3D; number[:] 即可拷贝一个新的集合 2.元祖（列表的近亲）3.字符串的bif：1.capitalize() 把首字母转换为大写 2.casefold() 把字符串中的字母全部转换为小写 3.center(length) 把一个字符串两边填充相同长度至length长度 4.count(sub[,start[,end]]) 返回sub在字符串中出现的次数，start和end参数表示范围，可选 5.encode(encoding&#x3D;”utf-8”,errors&#x3D;”strict”) 以指定的编码格式对字符串进行编码--encoding – 要使用的编码，如”UTF-8”。--errors – 设置不同错误的处理方案。默认为 ‘strict’,意为编码错误引起一个UnicodeError。 其他可能得值有 ‘ignore’, ‘replace’, ‘xmlcharrefreplace’, ‘backslashreplace’ 以及通过 codecs.register_error() 注册的任何值。 6.endswith(sub[,start[,end]])检查字符串是否已sub字符串结束，如果是返回True，否则返回False start和end参数表示范围，可选 7.expandtabs([tabsize&#x3D;8]) 把字符串中的tab符号(\\t) 转换Wie空格，如果不指定tabsize，则默认的tabsize&#x3D;8 8.find(sub[,start[,end]]) 检测sub是否包含在字符串中，如果有则返回索引值，否则返回-1，start和end参数表示范围，可选 9.index(sub[,start[,end]]) 跟find方法一样，不过如果sub不在string中会产生一个异常 10.isalnum() 如果字符串至少有一个字符并且所有字符都是字母或者数字则返回True,否则返回False 11.isalpha() 如果字符串至少有一个字符并且所有字符都是字母则返回True，否则返回False 12.isdecimal() 如果字符串只包含十进制数字则返回True，否则返回False 13.isdigit() 如果字符串只包含数字则返回True,否则返回False 14.islower() 如果字符串重至少包含一个区分大小写的字符，并且这些字符都是小写，则返回True,否则返回False 15.isnumeric() 如果字符串中只包含数字字符，则返回True,否则返回False 16.isspace() 如果字符串中只包含空格则返回True 否则返回False 17.istitle() 如果字符串是标题化，（所有的单词都是以大写开始，几区字母均小写）则返回True，否则返回False 18.isupper() 如果字符串中至少包含一个区分大小的字符，并且这些字符都是大写，则返回True，否则返回False 以下是常用的字符串的方法，包含了上面的一些已经举例的内容 4.字符串格式化符号含义及转义字符含字符串格式化符号含义 符号 说明 %c 格式化字符及其 ASCII 码 %s 格式化字符串 %d 格式化整数 %o 格式化无符号八进制数 %x 格式化无符号十六进制数 %X 格式化无符号十六进制数（大写） %f 格式化浮点数字，可指定小数点后的精度 %e 用科学计数法格式化浮点数 %E 作用同 %e，用科学计数法格式化浮点数 %g 根据值的大小决定使用 %f 或 %e %G 作用同 %g，根据值的大小决定使用 %f 或者 %E 格式化操作符辅助命令 符号 说明 — — m.n m 是显示的最小总宽度，n 是小数点后的位数 - 用于左对齐 + 在正数前面显示加号（+） # 在八进制数前面显示 ‘0o’，在十六进制数前面显示 ‘0x’ 或 ‘0X’ 0 显示的数字前面填充 ‘0’ 取代空格 Python 的转义字符及其含义 符号 说明 — — ‘ 单引号 “ 双引号 \\a 发出系统响铃声 \\b 退格符 \\n 换行符 \\t 横向制表符（TAB） \\v 纵向制表符 \\r 回车符 \\f 换页符 \\o 八进制数代表的字符 \\x 十六进制数代表的字符 \\0 表示一个空字符 \\ 反斜杠 序列list(列表) 如果没有给出参数，构造函数将创建一个新的空列表。如果指定，参数必须是可迭代的。 迭代器：重复反馈过程的活动就是 迭代 其目的通常是为了接近或者达到所需的目标 每次对这个过程的重复称作迭代，而每一次迭代得到的结果都会被作为下一次迭代的初始值tuple(元祖) 如果没有给出参数，构造函数返回一个空元组。如果指定了iterable，则从iterable的项初始化元组。 5.函数 6.局部变量和全局变量 不要直接在函数中去修改一个全局变量的值，如果修改的话，python会创建一个和全局变量同名的局部变量代替全局变量在函数中使用(shadowing 在函数中屏蔽掉全局变量并声明同名的局部变量) 如果非要在函数中去修改一个全局变量的值 在修改前加上global 告诉python编译器我是修改的全局变量 7.闭包(closure)闭包：如果在一个内部函数里对外部作用于（但不是在全局作用的变量进行引用）那么内部函数就会被认为是闭包（closure）闭包中的外部函数局部变量在闭包函数中的使用 8.lambda表达式 补充两个结合lambda实现的便捷BIF 1.filter(过滤器) filter(function or None, iterable) –&gt; filter object这个BIF有两个参数 如果第一个参数是一个function函数的话，就会把后面迭代器里面的值以参数的形式传递给前面的function 然后filter就会过滤掉function返回false的结果，得到返回true的结果，并返回一个list，如果第一个参数不是一个function的话，就会直接把第二个列表参数里面的返回true的结果返回。过滤掉false 并返回结果listeg： 2.map map(func, *iterables) –&gt; map objectmap有两个参数第一个参数是一个函数，第二个参数是一个可迭代的序列 这个bif的功能是将序列的每个元素作为function的参数传递到function中 然后在function内容将每一个元素进行运算加工，直到序列可迭代元素都加工完毕，返回所有加工后的元素构成的新序列（新list）eg: 9 递归1.补充知识 设置递归上限层级 10.字典 dict java中的map类型1.字典的符号是大括号{} 形式是key:value 相邻元素以逗号隔开eg:dict &#x3D; {“one”:1,”two”:2,”three”:3}， 2.字典可以通过添加键值对的形式添加元素，还可以通过key来添加value的形式改变或者添加到字典中eg dict[‘four’] &#x3D; 4 这个例子中，如果存在four这个key值的话就会修改掉原来key值对应的value值，如果key值不存在的话就会直接将这对key和value添加到字典中 3.dict()不是一个bif，是一个工厂函数（调用该方法会返回对应工厂所产生的是实例）4.字典所对应的bif函数：4.1.使用fromkeys创建并返回一个新的字典dict.fromkeys(key[,value]) 这个方法有两个参数，第一个参数是key值，第二个是key对应的的value value是可选的 4.2.keys()是返回字典键的引用。就是返回字典中所有的key值 例如在集合中for循环中遍历是 for i in dict.keys() 4.3.values 是返回字典值的引用返回字典中所有的value值，使用for循环遍历也是同样的效果 for val in dict.values() 4.4 items()是返回字典中的每一对key和value的键值对。相当于java map中的entry对象，返回每一组key:value 4.4 使用get()方法可以避免在索引值不存在的情况下抛出异常的情况。如果直接使用dict[len(dict)+1] 则会直接出现错误 KeyError: index ，如果是用get()方法则不会抛出异常，则会返回一个None eg:print(dict.get(len(dict)+1)) 这样的方法获取None这个方法支持第一个参数是字典中的索引值index，第二个值为如果找不到的情况下返回的值，如果找到则不会返回第二个参数值 eg：print(dict.get(len(dict)+1)，“不存在”) 返回的值是：不存在 4.5还可以通过成员资格操作符 in和not in判断这个key是否存在于字典中 key in dict 或者key not in dict存在返回True 不存在返回False 检查成员操作资格比序列更加高效，当字典中的数据相当大事，使用成员资格操作符的效率会更加高效 4.6 clear()方法用于清空一个字典eg:dict.clear() 则会把dict这个字典清空 4.7浅拷贝 copy() 拷贝复制给一个新的字典 新的!!，它们所对应的内存地址不相同 可以通过id()来查看补充知识:id()函数用于获取对象的内存地址 4.8 pop(key) 给定字典中的一个key值，弹出这个key对应的value值 这个方法有参数 就是key4.9 popitem() 给定字典中的一个key值，弹出包含这个key和对应的value的项，弹出key:value 这个方法没有参数，带参数报错4.10 setdefault() 给字典中添加一项 有两个参数，第一个参数必填 key 第二个参数选填value 没有设置第二个参数则value是None 如果设置第二个值则value是第二个参数4.11 update() 这个方法是利用一个字典或者映射关系去更新另一个字典 eg：dict.update({3,”三”}) 就可以将原先 3的映射“three”改为“三” 这个方法的关键是，他支持同时对多个keys的value值进行更改11 集合 set 字典的近亲 没有体现影射关系的就是集合 关键字 唯一无序，key唯一， 使用num1 &#x3D; list(set(num1)) 可以去去除num1中的重复的内容集合同样适用成员资格操作符来判断成员是否在这个集合中 1.集合的bif：1.1 add()追加元素 有一个参数1.2 remove() 从集合中移除 有一个参数1.3 frozenset() 不可变集合 不能使用add和remove 不能改变其内部的值12.文件操作1.文件的打开方式是open() 函数 返回一个文件对象open(file, mode&#x3D;’r’, buffering&#x3D;-1, encoding&#x3D;None, errors&#x3D;None, newline&#x3D;None, closefd&#x3D;True, opener&#x3D;None) 除了第一个是必填以外，其他的都是有默认值的参数列表:file 打开的文件 如果带路径就是打开对应路径下的文件，如果不带路径就是打来当前路径下的同名文件mode 打开文件的模式 “r” 以只读方式打开文件(默认) “w” 以写入的方式打开文件，会覆盖已存在的文件 “x” 如果文件已经存在，使用此模式打开将引发异常 “a” 以写入模式打开，如果文件存在，则在末尾追加写入 “b” 以二进制模式打开文件 “t” 以文本模式打开文件(默认) “+” 可读写模式(可添加到其他模式中使用) “U” 通用换行符支持 文件对象方法 文件对象方法 执行操作 — — f.close() 关闭文件 f.read([size&#x3D;-1]) 从文件读取size个字符，当未给定size或给定负值的时候，读取剩余的所有字符，然后作为字符串返回 f.readline([size&#x3D;-1]) 从文件中读取并返回一行（包括行结束符），如果有size有定义则返回size个字符 f.write(str) 将字符串str写入文件 f.writelines(seq) 向文件写入字符串序列seq，seq应该是一个返回字符串的可迭代对象 f.seek(offset, from) 在文件中移动文件指针，从from（0代表文件起始位置，1代表当前位置，2代表文件末尾）偏移offset个字节 f.tell() 返回当前在文件中的位置 f.truncate([size&#x3D;file.tell()]) 截取文件到size个字节，默认是截取到文件指针当前位置 13.OS模块os模块中关于文件&#x2F;目录常用的函数使用方法 函数名 使用方法 getcwd() 返回当前工作目录 chdir(path) 改变工作目录 listdir(path&#x3D;’.’) 列举指定目录中的文件名（’.’表示当前目录，’..’表示上一级目录） mkdir(path) 创建单层目录，如该目录已存在抛出异常 makedirs(path) 递归创建多层目录，如该目录已存在抛出异常，注意：’E:\\a\\b’和’E:\\a\\c’并不会冲突 remove(path) 删除文件 rmdir(path) 删除单层目录，如该目录非空则抛出异常 removedirs(path) 递归删除目录，从子目录到父目录逐层尝试删除，遇到目录非空则抛出异常 rename(old, new) 将文件old重命名为new system(command) 运行系统的shell命令 walk(top) 遍历top路径以下所有的子目录，返回一个三元组：(路径, [包含目录], [包含文件])【具体实现方案请看：第30讲课后作业^_^】 以下是支持路径操作中常用到的一些定义，支持所有平台 os.curdir 指代当前目录（’.’） os.pardir 指代上一级目录（’..’） os.sep 输出操作系统特定的路径分隔符（Win下为’\\‘，Linux下为’&#x2F;‘） os.linesep 当前平台使用的行终止符（Win下为’\\r\\n’，Linux下为’\\n’） os.name 指代当前使用的操作系统（包括：’posix’, ‘nt’, ‘mac’, ‘os2’, ‘ce’, ‘java’） 14 os.path模块中关于路径常用的函数使用方法 函数名 使用方法 basename(path) 去掉目录路径，单独返回文件名 dirname(path) 去掉文件名，单独返回目录路径 join(path1[, path2[, …]]) 将path1, path2各部分组合成一个路径名 split(path) 分割文件名与路径，返回(f_path, f_name)元组。如果完全使用目录，它也会将最后一个目录作为文件名分离，且不会判断文件或者目录是否存在 splitext(path) 分离文件名与扩展名，返回(f_name, f_extension)元组 getsize(file) 返回指定文件的尺寸，单位是字节 getatime(file) 返回指定文件最近的访问时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算） getctime(file) 返回指定文件的创建时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算） getmtime(file) 返回指定文件最新的修改时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算） 以下为函数返回 True 或 False exists(path) 判断指定路径（目录或文件）是否存在 isabs(path) 判断指定路径是否为绝对路径 isdir(path) 判断指定路径是否存在且是一个目录 isfile(path) 判断指定路径是否存在且是一个文件 islink(path) 判断指定路径是否存在且是一个符号链接 ismount(path) 判断指定路径是否存在且是一个挂载点 samefile(path1, paht2) 判断path1和path2两个路径是否指向同一个文件 15.pickle(泡菜) 模块 用于吧列表 元祖 集合 字典等对象形式的数据装换二进制的数据eg: 16 python中的异常 AssertionError 断言语句（assert）失败 AttributeError 尝试访问未知的对象属性 EOFError 用户输入文件末尾标志EOF（Ctrl+d） FloatingPointError 浮点计算错误 GeneratorExit generator.close()方法被调用的时候 ImportError 导入模块失败的时候 IndexError 索引超出序列的范围 KeyError 字典中查找一个不存在的关键字 KeyboardInterrupt 用户输入中断键（Ctrl+c） MemoryError 内存溢出（可通过删除对象释放内存） NameError 尝试访问一个不存在的变量 NotImplementedError 尚未实现的方法 OSError 操作系统产生的异常（例如打开一个不存在的文件） OverflowError 数值运算超出最大限制 ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象 RuntimeError 一般的运行时错误 StopIteration 迭代器没有更多的值 SyntaxError Python的语法错误 IndentationError 缩进错误 TabError Tab和空格混合使用 SystemError Python编译器系统错误 SystemExit Python编译器进程被关闭 TypeError 不同类型间的无效操作 UnboundLocalError 访问一个未初始化的本地变量（NameError的子类） UnicodeError Unicode相关的错误（ValueError的子类） UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类） UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类） UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类） ValueError 传入无效的参数 ZeroDivisionError 除数为零 以下是 Python 内置异常类的层次结构： BaseException +– SystemExit +– KeyboardInterrupt +– GeneratorExit +– Exception +– StopIteration +– ArithmeticError +– FloatingPointError +– OverflowError +– ZeroDivisionError +– AssertionError +– AttributeError +– BufferError +– EOFError +– ImportError +– LookupError +– IndexError +– KeyError +– MemoryError +– NameError +– UnboundLocalError +– OSError +– BlockingIOError +– ChildProcessError +– ConnectionError +– BrokenPipeError +– ConnectionAbortedError +– ConnectionRefusedError +– ConnectionResetError +– FileExistsError +– FileNotFoundError +– InterruptedError +– IsADirectoryError +– NotADirectoryError +– PermissionError +– ProcessLookupError +– TimeoutError +– ReferenceError +– RuntimeError +– NotImplementedError +– SyntaxError +– IndentationError +– TabError +– SystemError +– TypeError +– ValueError +– UnicodeError +– UnicodeDecodeError +– UnicodeEncodeError +– UnicodeTranslateError +– Warning +– DeprecationWarning +– PendingDeprecationWarning +– RuntimeWarning +– SyntaxWarning +– UserWarning +– FutureWarning +– ImportWarning +– UnicodeWarning +– BytesWarning +– ResourceWarning 异常的捕获： 16.1.try excepteg: 和java一样 except是可以多层嵌套的，不同类型的异常使用不用的处理方式except 后面不跟异常的类型表示在前面的except 所对应的异常类型没有符合的，就进入都最后的except（后面不带异常类型）中 16.2 try except finally这个的用法和java很相似 不做过多注释 16.3raise 抛出一个异常 类似于java throw 的作用 raise 后面写一个异常的类型（异常的参数） 和java类似17 丰富的else语句和简洁的with语句1.else和if语句搭配可以实现 “要么怎样，要么不怎样” 的逻辑处理2.else和循环语句for或者while搭配实现 “干完了能怎样，干不完就别想怎样” 的逻辑处理3.else和try except异常处理搭配实现“没有问题的话怎样” 的逻辑处理第一种举例： 第二种举例 第三种举例： with是相当于java 1.7更新的内存流自动关闭的特性比如你再读取文件的时候，你读取一个不存在的文件肯定会发生异常，但你发生异常之后使用finally去关闭的时候，你会先没有开启这个文件的open，所以就会出问题，当你使用with之后，如果文件打开之后，他会自动关闭 17.图形用户界面 easygui1.下载并解压  去github下载easygui模块包 然后解压2.使用命令行切换到下载的easygui路径下，然后输入python setup.py install3实例eg 4.扩展阅读: 小甲鱼翻译的easygui中文教程 18.面向对象1.三大特征 封装、继承、多态 和java一样2.创建类 3.创建对象 4.继承 5.封装私有私有属性、方法——Python并没有真正的私有化支持，但可用下划线得到伪私有 尽量避免定义以下划线开头的变量 （1）_xxx “单下划线 “ 开始的成员变量叫做保护变量，意思是只有类对象（即类实例）和子类对象自己能访问到这些变量，需通过类提供的接口进行访问；不能用’from module import *‘导入 （2）xxx 类中的私有变量&#x2F;方法名 （Python的函数也是对象，所以成员方法称为成员变量也行得通。）,” 双下划线 “ 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。 （3）xxx__ 系统定义名字，前后均有一个“双下划线” 代表python里特殊方法专用的标识，如 init() 代表类的构造函数 6.self对象的作用和方法，self相当于是java中的this，但不全是，self是一个中间变量，用来做绑定可能比较合适意思，因为，当你的实力对象调用父类的方法的时候，需要通过self来绑定你调用的这个实力对象，但是，这个对象不用显式的传递，只需要在父类的定义方法时，将self写在形式参数的第一个位置，然后在方法里面去使用self来传递参数7.对象和类的一些BIF7.1.insubclass(class,classinfo) 如果第一个参数对象是第二个参数对象的子类的话，就会返回True（非严格性的检查，一个类被认为是他自己的子类，第二个参数可以为一个元素，多个中找一个）7.2 isinstance(Object,classInfo) 这是用来检查一个实例对象是否是一个class的实例 ，就是参数1是否是参数2的实例对象7.3 hasattr(object,name) 判断一个实例对象中是否有指定的属性7.4 getattr(object,name[,defaultValue]) 获取对象的指定name属性值，如果设置了defaultValue的值，在没有获取成功的情况下，则会返回defaultValue的值，如果没有设置defaultValue的值，则会抛出一个attrError7.5 setattr(object,name,value) 设置一个对象的属性值，如果不存在会创建一个并设置这个属性值7.6 delattr(object,name)删除对象的一个属性，如果不存在则会抛出一个异常，存在则删除7.7 property(fget&#x3D;None,fset&#x3D;None,fdel&#x3D;None,fdoc&#x3D;None) 是通过属性来操作属性的方法eg: 7.8 “__ init __(self[,attrvalue])” 是构造方法 和ava的构造方法一样，这个方法是不用做返回值，也不能返回值7.9 “__ new __(class[,attrvalue])” 是创建对象的方法7.10 ‘__ del __(self) ’这个是对象在没有任何标签指向该对象时，被垃圾回收机制回收的时候调动的方法 相当于java.的finaline()方法8.魔法方法 魔法方法 含义 基本的魔法方法 new(cls[, …]) 1. new 是在一个对象实例化的时候所调用的第一个方法 2. 它的第一个参数是这个类，其他的参数是用来直接传递给 init 方法 3. new 决定是否要使用该 init 方法，因为 new 可以调用其他类的构造方法或者直接返回别的实例对象来作为本类的实例，如果 new 没有返回实例对象，则 init 不会被调用 4. new 主要是用于继承一个不可变的类型比如一个 tuple 或者 string init(self[, …]) 构造器，当一个实例被创建的时候调用的初始化方法 del(self) 析构器，当一个实例被销毁的时候调用的方法 call(self[, args…]) 允许一个类的实例像函数一样被调用：x(a, b) 调用 x.call(a, b) len(self) 定义当被 len() 调用时的行为 repr(self) 定义当被 repr() 调用时的行为 str(self) 定义当被 str() 调用时的行为 bytes(self) 定义当被 bytes() 调用时的行为 hash(self) 定义当被 hash() 调用时的行为 bool(self) 定义当被 bool() 调用时的行为，应该返回 True 或 False format(self, format_spec) 定义当被 format() 调用时的行为 有关属性 getattr(self, name) 定义当用户试图获取一个不存在的属性时的行为 getattribute(self, name) 定义当该类的属性被访问时的行为 setattr(self, name, value) 定义当一个属性被设置时的行为 delattr(self, name) 定义当一个属性被删除时的行为 dir(self) 定义当 dir() 被调用时的行为 get(self, instance, owner) 定义当描述符的值被取得时的行为 set(self, instance, value) 定义当描述符的值被改变时的行为 delete(self, instance) 定义当描述符的值被删除时的行为 比较操作符 lt(self, other) 定义小于号的行为：x &lt; y 调用 x.lt(y) le(self, other) 定义小于等于号的行为：x &lt;&#x3D; y 调用 x.le(y) eq(self, other) 定义等于号的行为：x &#x3D;&#x3D; y 调用 x.eq(y) ne(self, other) 定义不等号的行为：x !&#x3D; y 调用 x.ne(y) gt(self, other) 定义大于号的行为：x &gt; y 调用 x.gt(y) ge(self, other) 定义大于等于号的行为：x &gt;&#x3D; y 调用 x.ge(y) 算数运算符 add(self, other) 定义加法的行为：+ sub(self, other) 定义减法的行为：- mul(self, other) 定义乘法的行为：* truediv(self, other) 定义真除法的行为：&#x2F; floordiv(self, other) 定义整数除法的行为：&#x2F;&#x2F; mod(self, other) 定义取模算法的行为：% divmod(self, other) 定义当被 divmod() 调用时的行为 pow(self, other[, modulo]) 定义当被 power() 调用或 ** 运算时的行为 lshift(self, other) 定义按位左移位的行为：&lt;&lt; rshift(self, other) 定义按位右移位的行为：&gt;&gt; and(self, other) 定义按位与操作的行为：&amp; xor(self, other) 定义按位异或操作的行为：^ or(self, other) 定义按位或操作的行为： 反运算 radd(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rsub(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rmul(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rtruediv(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rfloordiv(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rmod(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rdivmod(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rpow(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rlshift(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rrshift(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rand(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） rxor(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） ror(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） 增量赋值运算 增量赋值运算 iadd(self, other) 定义赋值加法的行为：+&#x3D; isub(self, other) 定义赋值减法的行为：-&#x3D; imul(self, other) 定义赋值乘法的行为：*&#x3D; itruediv(self, other) 定义赋值真除法的行为：&#x2F;&#x3D; ifloordiv(self, other) 定义赋值整数除法的行为：&#x2F;&#x2F;&#x3D; imod(self, other) 定义赋值取模算法的行为：%&#x3D; ipow(self, other[, modulo]) 定义赋值幂运算的行为：**&#x3D; ilshift(self, other) 定义赋值按位左移位的行为：&lt;&lt;&#x3D; irshift(self, other) 定义赋值按位右移位的行为：&gt;&gt;&#x3D; iand(self, other) 定义赋值按位与操作的行为：&amp;&#x3D; ixor(self, other) 定义赋值按位异或操作的行为：^&#x3D; ior(self, other) 定义赋值按位或操作的行为： 一元操作符 一元操作符 pos(self) 定义正号的行为：+x neg(self) 定义负号的行为：-x abs(self) 定义当被 abs() 调用时的行为 invert(self) 定义按位求反的行为：~x 类型转换 类型转换 complex(self) 定义当被 complex() 调用时的行为（需要返回恰当的值） int(self) 定义当被 int() 调用时的行为（需要返回恰当的值） float(self) 定义当被 float() 调用时的行为（需要返回恰当的值） round(self[, n]) 定义当被 round() 调用时的行为（需要返回恰当的值） index(self) 1. 当对象是被应用在切片表达式中时，实现整形强制转换 2. 如果你定义了一个可能在切片时用到的定制的数值型,你应该定义 index 3. 如果 index 被定义，则 int 也需要被定义，且返回相同的值 上下文管理（with 语句） enter(self) 1. 定义当使用 with 语句时的初始化行为 2. enter 的返回值被 with 语句的目标或者 as 后的名字绑定 exit(self, exc_type, exc_value, traceback) 1. 定义当一个代码块被执行或者终止后上下文管理器应该做什么 2. 一般被用来处理异常，清除工作或者做一些代码块执行完毕之后的日常工作 容器类型 容器类型 len(self) 定义当被 len() 调用时的行为（返回容器中元素的个数） getitem(self, key) 定义获取容器中指定元素的行为，相当于 self[key] setitem(self, key, value) 定义设置容器中指定元素的行为，相当于 self[key] &#x3D; value delitem(self, key) 定义删除容器中指定元素的行为，相当于 del self[key] iter(self) 定义当迭代容器中的元素的行为 reversed(self) 定义当被 reversed() 调用时的行为 contains(self, item) 定义当使用成员测试运算符（in 或 not in）时的行为 "},{"title":"OpenResty实战","date":"2023-05-31T10:43:18.000Z","url":"/2023/05/31/OpenResty%E5%AE%9E%E6%88%98/","tags":[["OpenResty","/tags/OpenResty/"]],"categories":[[" ",""]],"content":"OpenResty实战教程,对文件访问地址进行验证,如果未携带token,或者时间已经过期,则返回401并提示token无效或者token已过期1.解释一下,啥是OpenResty? 2.源码安装Openresty,为了固定版本,多服务下部署下减少版本之间不兼容1.文件下载地址 2.安装 3 编辑nginx.conf配置文件 4.在conf目录下添加token.lua脚本"},{"title":"JPA常用API","date":"2023-05-31T04:43:18.000Z","url":"/2023/05/31/JPA%E5%B8%B8%E7%94%A8API/","tags":[["JPA常用API","/tags/JPA%E5%B8%B8%E7%94%A8API/"]],"categories":[[" ",""]],"content":"自定义方法的实现:Jpa本身还提供了一些自定义声明方法的规则，例如：在接口中使用关键字findBy、readBy、getBy作为方法名的前缀，拼接实体类中的属性字段（首字母大写），并可选择拼接一些SQL关键字来组合成一个查询方法，例如，对于用户实体，关键字可以这样使用 And，如：findByIdAndName(Long id, String name); 并且 Or,如：findByIdOrName(Long id, String name); 或者 Between,如：findByCreateDateBetween(Date start, Date end); 在之间 LessThan,如：findByCreateDateLessThan(Date start); 小于 GreaterThan,如：findByCreateDateGreaterThan(Date start); 大于 IsNull,如：findByNameIsNull(); 空 IsNotNull,与上等价 不等于空 Like,如：findByNameLike(String name); 模糊查询 NotLike:与上等价 不模糊 OrderBy,如：findByNameOrderByIdAsc(String name); 排序 Not,如：findByNameNot(String name); 不得于 In,如：findByNameIn(Collection nameList); 在什么里面 数组 NotIn,与上等价。不在什么里面 数组 top&#x2F;limit 查询方法结果的数量通过关键字限制 默认1，可以加数字指定返回最大结果 例如: User findFirstByOrderByLastnameAsc(); User findTopByOrderByAgeDesc(); Page queryFirst10ByLastname(String lastname, Pageable pageable); Slice findTop3ByLastname(String lastname, Pageable pageable); List findFirst10ByLastname(String lastname, Sort sort); List findTop10ByLastname(String lastname, Pageable pageable);你同样可以写一个自定义的方法，使用@Query注解+HQL语句实现你想要的效果 详细查询语法 关键词 示例 对应的sql片段 And findByLastnameAndFirstname … where x.lastname = ?1 and x.firstname = ?2 Or findByLastnameOrFirstname … where x.lastname = ?1 or x.firstname = ?2 Is,Equals findByFirstname,findByFirstnameIs,findByFirstnameEquals … where x.firstname = ?1 Between findByStartDateBetween … where x.startDate between ?1 and ?2 LessThan findByAgeLessThan … where x.age &lt; ?1 LessThanEqual findByAgeLessThanEqual … where x.age &lt;= ?1 GreaterThan findByAgeGreaterThan … where x.age &gt; ?1 GreaterThanEqual findByAgeGreaterThanEqual … where x.age &gt;= ?1 After findByStartDateAfter … where x.startDate &gt; ?1 Before findByStartDateBefore … where x.startDate &lt; ?1 IsNull findByAgeIsNull … where x.age is null IsNotNull,NotNull findByAge(Is)NotNull … where x.age not null Like findByFirstnameLike … where x.firstname like ?1 NotLike findByFirstnameNotLike … where x.firstname not like ?1 StartingWith findByFirstnameStartingWith … where x.firstname like ?1 (parameter bound with appended %) EndingWith findByFirstnameEndingWith … where x.firstname like ?1 (parameter bound with prepended %) Containing findByFirstnameContaining … where x.firstname like ?1 (parameter bound wrapped in %) OrderBy findByAgeOrderByLastnameDesc … where x.age = ?1 order by x.lastname desc Not findByLastnameNot … where x.lastname &lt;&gt; ?1 In findByAgeIn(Collection&lt;Age&gt; ages) … where x.age in ?1 NotIn findByAgeNotIn(Collection&lt;Age&gt; ages) … where x.age not in ?1 True findByActiveTrue() … where x.active = true False findByActiveFalse() … where x.active = false IgnoreCase findByFirstnameIgnoreCase … where UPPER(x.firstame) = UPPER(?1) "},{"title":"Yay","date":"2023-05-31T04:43:18.000Z","url":"/2023/05/31/Yay/","tags":[["Yay","/tags/Yay/"]],"categories":[[" ",""]],"content":" yay是一个AUR Helper，他可以执行pacman的几乎所有操作，并在此基础上添加了很多额外用法。 我没有在网络上查找到关于yay的、除了pacman基础用法和安装AUR包以外的中文教程，英文的也几乎没有看到，这也是我写这篇文章的原因所在。 本文通篇详讲yay的每一个设置&#x2F;选项（大概就是archwiki那种干涩的行文思路），最后会给出我自己的一些常用命令，但不会做解释。 写作时参考了yay的英文使用手册，如果你的arch安装了yay，那么即可通过man yay命令随时查阅它。 Tips1: 本文中出现的foo一般是指包名，标注*的表示该选项默认启用。 Tips2: 使用电脑端的访客可以在侧栏以获取目录。 “基本用法”)基本用法[]yay的基本用法是yay &lt;operation&gt; [options] [targets]、yay foo和yay，yay &lt;operation&gt; [options] [targets]的用法可以讨论的点比较多，我会在后文中一一道来。 yay当我们仅执行yay，后面不跟任何参数时，yay会执行操作yay -Syu，他会先调用pacman更新源的数据库、更新所有从源内安装的软件包，并检查你的AUR包有没有更新。 yay foo通过yay后面直接跟包名的命令会让yay直接在源和AUR内搜索带有foo关键词的包（包名和简介中只要出现foo都会被一网打尽），以下是我执行yay dingtalk的输出 输入每一项对应的序号即可进入相应的安装过程。 yay &lt;operation&gt; [options] [targets]在这里，每次只能有一个，[options]和[targets]可以有多个，且多个[options]可以合起来写在一起。比如yay -P -s -f可以直接写成yay -Psf，顺序也可以颠倒，-Psf和-sPf没区别。 -Y (--yay)-Y行为其实是yay的默认行为，当你没有加其他的行为参数时，yay就会执行-Y参数，可以跟--gendb和-c。 –gendb&#96;生成AUR数据库。仅当从另一个AUR Helper迁移到yay时，才应使用此选项。（根据我的个人理解，是根据你Arch内安装的源内找不到的包的包名去AUR里寻找对应的PKGBUILD，并且把能找到的PKGBUILD给clone到~/.cache/yay/目录下） 千玄子大佬说：“简单说来就是把在 AUR 的 PKGBUILD 下下来然后比对是否要更新。” -c（--clean）清除不再需要的、没有被依赖的包。（相当于apt中的autoremove） -P(--show)执行特定的Print操作。可以跟的[option]有-c、-f、-d、-g、-n、-s、-u、-w、-q -c(--complete)Print所有源内和AUR软件包的列表。这是给命令行操作提供的，并不打算由用户直接使用。（意思是启用了这个选项以后你的终端会出现一大串长常的列表来告诉你你的Arch到底可以从哪里安装哪些包，并不是直接给你用的，是作为数据留给别的命令来玩耍的） -f(--fish)在输出结果到终端时，会专门为fish用户做微调。（但是根据SamLukeYes大佬说他用fish体验下来并没有感知到加不加有什么区别，应该是属于感知不强的选项） -d(--defaultconfig)Print默认的yay配置。 -g(--currentconfig)Print当前的yay配置。 -n(--numberupgrades)数一数你现在还有多少AUR包待更新。yay作者不推荐你使用呢，他推荐你用yay -Qu或者wc -l来代替它。 -s(--stats)会展示一大堆信息，如下 -u(--upgrades)展示你所有待更新的包。 -w(--news)展示来自archlinux.org的新闻。需要注意的是，这里的新闻是具有时效性的，只有在你的Arch最后一次更新以后发出来的新闻才会被显示出来。如果你不想要yay判断新闻时效性，你可以通过yay -Pww（即两个w）来获取所有能获得的新闻。 -q(--quiet)在输出新闻的时候，仅输出新闻的标题。该功能需要与-w连用，即yay -Pwq。 -G(--getpkgbuild)后跟包名。需要注意的是，如果指定的包不存在于官方源，则无法输出，后跟-f、-p参数。 如果希望仅获取来自AUR（即排除第三方源的干扰）的PKGBUILD，后需跟-a参数。 -f(--force)强制下载AUR中的PKGBUILD，如果它在yay缓存目录已经存在了，那就覆盖它！ -p(--print)Print指定包的PKGBUILD。 pacman 拓展用法yay虽然可以使用pacman的所有，但是它远不仅于此。在这一段，我将向你介绍yay中包含的那些pacman不包括的pacman &lt;operation -S-S, -Si, -Sl, -Ss, -Su, -Sc, -Qu这些操作pacman都支持，而与pacman不同的是，yay的这些操作可以涵盖到官方源&#x2F;第三方源和AUR中的所有包。 -Scyay将会清除AUR包构建时的缓存和没有被track的文件。没有被track的文件在这里指AUR包构建时下载的sources或者构建完成的pkg包，但是vcs sources会被保留（比如.git文件夹） 全局的[options]全局是指在所有下都可以加啦。 #####--repo 假定你给出的包名只存在源里（忽视AUR的存在） -a(--aur)假定你给出的包名只存在AUR中（忽视源的存在） 配置设置原版的man手册排的比较混乱，我这里自己细分了几个类型，或许不是特别专业，但我希望能够帮助你们理解。 自定义调用命令型--editor &lt;command&gt;设置编辑时调用的编辑器。 #####--makepkg &lt;command&gt; 设置makepkg时需要调用makepkg命令（一般情况下用不到） --pacman &lt;command&gt;设置运行pacman时需要调用pacman命令（一般情况下用不到） --tar &lt;command&gt;设置makepkg解压tar资源时调用的tar命令（一般情况下用不到） --git &lt;command&gt;设置makepkg clone git资源时调用的git命令（比如你可以安装AUR中的fgit-go，使用--git fgit参数来让fastgit代理clone的过程） --gpg &lt;command&gt;设置gpg验证资源时调用的gpg命令 --sudo &lt;command&gt;设置调用sudo获取su权限安装pkg时所调用的sudo命令。 自定义配置文件型--config &lt;file&gt;设置读取的pacman配置文件。 --makepkgconf &lt;file&gt;设置读取的makepkg配置文件。 --nomakepkgconf不读取系统中的makepkg.conf，仅使用Arch默认状态下的配置文件。 自定义路径类型--builddir &lt;dir&gt;设置build路径，默认路径为~/.cache/yay/ --absdir &lt;dir&gt;设置abs路径，默认路径为~/.cache/yay/abs/ 参数传递型--editorflags &lt;flags&gt;后跟需要跟随传递给编辑器的参数。如果需要传递多个参数，可以使用引号。 --mflags &lt;flags&gt;后跟需要跟随传递给makepkg的参数。如果需要传递多个参数，可以使用引号。 这个用的人不多，但其实是非常好用的一个功能。在我们安装deepin-wine-tim等包的时候，很可能会遇到文件明明完整但checksum不通过的情况，这时我们可以跟一个--skipchecksums参数传递给makepkg以跳过checksum的过程。 --gpgflags &lt;flags&gt;后跟需要跟随传递给pgp的参数。如果需要传递多个参数，可以使用引号。 --sudoflags &lt;flags&gt;后跟需要跟随传递给sudo的参数。如果需要传递多个参数，可以使用引号。 菜单配置型clean菜单--cleanmenu启用清除询问菜单。（询问你是否需要清除已存在的文件） --nocleanmenu禁用清除询问菜单。（不询问你是否需要清除已存在的文件） --answerclean自动回答cleanmenu，后跟&lt;All|None|Installed|NotInstalled&gt;参数。 --noanswerclean不设置自动回答。 diff菜单--diffmenu启用对比询问菜单。（询问你是否需要对比本地文件和AUR文件） --nodiffmenu禁用对比询问菜单。（不询问你是否需要对比本地文件和AUR文件） --answerdiff自动回答cleanmenu，后跟&lt;All|None|Installed|NotInstalled&gt;参数。 --noanswerdiff不设置自动回答。 edit菜单#####--editmenu 启用修改询问菜单。（询问你是否需要修改PKGBUILD以及相关文件） --noeditmenu禁用修改询问菜单。（不询问你是否需要修改PKGBUILD以及相关文件） --answeredit自动回答editmenu，后跟&lt;All|None|Installed|NotInstalled&gt;参数。 --noansweredit不设置自动回答。 upgrade菜单--upgrademenu启用更新询问菜单。（询问你是否需要更新AUR包） --noupgrademenu禁用更新询问菜单。（不询问你是否需要更新AUR包） --answerupgrade自动回答upgrademenu，后跟&lt;All|None|Installed|NotInstalled&gt;参数。 --noanswerupgrade不设置自动回答。 removemake菜单--askremovemake在编译结束后，询问是否删除make depend。 --removemake在编译结束后，删除make depend。 --noremovemake在编译结束后，不删除make depend。 provides菜单[--provides搜索AUR包时，一同寻找其在AUR上的依赖程序。 当找到多个提供该依赖的包时，将出现一个菜单，提示您选择一个。尽管这不会引起注意，但这会增加依赖项解决时间。 --noprovides搜索AUR包时，不在AUR上寻找其依赖程序。尽管yay不会再次弹出依赖菜单供你选择，yay调用pacman时依然会出现pacman的选择菜单让你选择。 pgpfetch菜单--pgpfetch询问你是否从每个PKGBUILD的validpgpkeys字段导入未知的PGP密钥。 --nopgpfetch不自动导入陌生的PGP密钥。 useask选项--useask调用pacman的–ask询问用户是否删除系统中与当前包冲突的软件包。 --nouseask不调用pacman的–ask询问用户是否删除系统中与当前包冲突的软件包，遇到冲突的软件包时直接报错，由用户来手动解决。 combinedupgrade菜单--combinedupgrade在系统更新期间，将源内包和AUR包的更新菜单合并到一起。 --nocombinedupgrade在系统更新期间，先支持源内包的升级，完成后再进行AUR包的升级。 T or F 型devel--devel在系统更新期间，检查AUR的vcs包是否有更新，当前仅支持AUR的-git包。 devel查询是使用git ls-remote对比安装时和现在最新的commit_id完成的。 --nodevel在系统更新期间， 不检查AUR的vcs包是否有更新。 timeupdate--timeupdate在系统更新期间，将已安装软件包的构建时间与每个软件包的AUR的最后修改时间进行比较。 --notimeupdate在系统更新期间，不将已安装软件包的构建时间与每个软件包的AUR的最后修改时间进行比较。 redownload--redownload就算PKGBUILD已经存在，也要重新从AUR上获取一份新的PKGBUILD并覆盖原有PKGBUILD。 --redownloadall就算PKGBUILD已经存在，也要重新从AUR上获取所有AUR包的PKGBUILD并覆盖原有PKGBUILD。 --noredownload当下载PKGBUILD时，，如果发现cache中的PKGBUILD版本＞＝AUR上的版本时，直接使用本地的PKGBUILD。 rebuild--rebuild即使在cache中有可用的二进制包的情况下，也始终要重新编译目标软件包。 --rebuildall即使在cache中有可用的二进制包的情况下，也始终要重新编译所有的AUR包。 --rebuildtree安装AUR包时，以递归方式重新编译并重新安装其所有AUR依赖包，即使已安装的依赖项也是如此。 该选项使您可以轻松地针对当前系统的库重新构建软件包，如果它们变得不兼容。（比如python3.8-&gt;3.9） --norebuild构建软件包时，如果在缓存中找到该软件包并且该软件包与想要的软件包的版本相同，则跳过软件包的编译过程并使用现有的二进制程序。 sudoloop--sudoloop在后台循环调用sudo，以防止sudo授权在长时间构建期间超时。 --nosudoloop不在后台循环调用sudo，可能会导致sudo授权在长时间构建期间超时。 batchinstall--batchinstall在构建和安装AUR包时，对每个软件包的安装进行排序，而并非在构建之后立刻安装每个软件包时。 需要注意的是，一旦构建了所有软件包，或者需要构建队列中的软件包作为构建另一个软件包的依赖项，应当在安装队列中安装所有软件包。 --nobatchinstall在构建AUR包成功后立即安装。 clearafter--cleanafter在构建AUR包完成以后清除cache文件。 --nocleanafter在构建AUR包完成以后不清除cache文件。 其他型--save把你这一次执行yay后面跟的配置参数永久保存下来。 --aururl更改aur源地址（默认为 []），适用于中国用户，可以使用此参数将AUR的地址设置成清华的反代，具体的配置命令为 TUNA 的反代已经取消，可以使用如下命令设置回 AUR 官方源 --sortby在搜索过程中，按特定条件对AUR结果进行排序，后跟&lt;votes|popularity|id|baseid|name|base|submitted|modified参数，默认为votes。 --searchby通过指定查询类型来搜索AUR软件包，后跟&lt;name|name-desc|maintainer|depends|checkdepends|makedepends|optdepends参数，默认为name-desc。 --topdown优先展示源内包，其次才是AUR包 --bottomup优先展示AUR包，其次才是源内包 --requestsplitn &lt;number&gt;设置在每次向AUR的请求的最大数值（默认150）。数值越高，请求时间越短，但是单次请求的数值过大会导致error。当这个数值＞500时你应当特别注意这一点。 --completioninterval &lt;days&gt;刷新完成高速缓存的时间（以天为单位,默认为7）。 将此值设置为0将导致每次刷新缓存，而将其设置为-1将导致永远不刷新缓存。"},{"title":"Docker常用命令","date":"2023-05-31T04:43:18.000Z","url":"/2023/05/31/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","tags":[["Docker常用命令","/tags/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"]],"categories":[[" ",""]],"content":"1.安装之后启动docker 2.docker添加镜像 3. docker 运行镜像 4.docker 结束掉运行的镜像 CONTANER ID 可通过docker ps 查看正在运行的镜像 5.查看正在运行的镜像 查看所有的镜像 之前运行过的 6.移除仓库里面的镜像文件 IMAGE ID可通过docker images 查看仓库中已存在的镜像 7.查看仓库中已存在的镜像 8.镜像的启动与停止 9.进入镜像 2.常用工具端口2.1.redis 63792.2 mongoDB 2.3.rabbitMQ 2.4docker自动操作防火墙开放端口 docker 在docker容器中使用clear命令失败解决方法 docker启动失败 查看失败原因"},{"title":"JVM 学习","date":"2023-05-31T04:43:18.000Z","url":"/2023/05/31/jvm/","tags":[["JVM 学习","/tags/JVM-%E5%AD%A6%E4%B9%A0/"]],"categories":[[" ",""]],"content":"JVM生命周期： 14-JVM的生命周期 P14 - 00:05 1.虚拟机的启动 java虚拟机的启动是通过引导类加载器（bootstrap class loader） 创建一个初始类（initial class）来完成的，这个类是有虚拟机的集体实现指定的 2.虚拟机的执行 一个运行中的java虚拟机有着一个清晰的任务：执行java程序。 程序开始执行时他才运行，程序结束时他就停止 执行一个所谓的java程序的时候，真真正正在执行的是一个叫做java虚拟机的进程 3.虚拟机的退出 程序正常执行结束 程序在执行过程和总遇到了异常或者错误而异常终止 由于操作系统出现错误而导致java虚拟机进程终止 某线程调用Runtime类或者System类的exit方法，或者Runtime类的halt方法，并且java安全管理器也允许这次exit或者halt操作 （System.exit方法实际上也是去调用了Runtime类的halt方法（Runtime是一个饿汉式加载的运行时数据区（Runtime Data Area）每个运行时的虚拟机独有一份 包含了 方法区、java栈、本地方法栈、堆、程序计数器）） 除此之外，JNT（Java Native Interface）规范描述了用JNT Invocation APi来加载或卸载Java虚拟机时，Java虚拟机的退出情况 JVM的发展历程 1.Sun Classis VM 世界第一款商用java虚拟机 1.4被淘汰 内部只提供解释器（不提供JIT即时编译器）效率底下。 15-SUN Classic VM的介绍 P15 - 00:06 2.Exact V****M准确式内存管理（可以知道内存中某个位置的数据具体是什么类型的数据）热点探测，编译器和结束器混合工作模式 16-Exact VM的介绍 P16 - 00:02 3.HotSpot V****M（目前正在使用中）JDK3之后到目前一直是作为默认虚拟机，Oracle JDK&#x2F;Open JDK的默认虚拟机，服务器，桌面，移动端，嵌入式都有使用，拥有热点探测技术 （方法区的概念只有HotSpot虚拟机有，jRock&#x2F;J9都没有方法去概念） 17-HotSpot VM的介绍 P17 - 00:02 4.JRockit V****M（BEA（已经被Oracle收购）） 内部不包含解释器实现，全部代码都靠即时编译器编译之后执行，世界上最快的JVM 18-JRockit VM的介绍 P18 - 00:03 5.J9 VM（IBM） 执行IBM公司的产品速度快，定位接近HotSpot 其他产品优化不及IBM公司产品，不稳定 19-IBM J9 VM的介绍 P19 - 00:03 6.KVM和CDC &#x2F;CLDC HotSpot （CDC &#x2F;CLDC HotSpot java ME产品线上的两款虚拟机）KVM是进军移动端的JVM用量小（android 和IOS占据） 20-KVM、CDC、CLDC的介绍 P20 - 00:02 7.Azul VM 特定硬件平台绑定，软硬件配合的专有虚拟机（每个Auzl vm实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内，实现可控的GC时间的垃圾收集器，专有硬件优化的线程调度等优秀特性） 21-Azul VM和BEA Liquid VM的介绍 P21 - 00:01 8.Liquid VM和Azul VM类似 特定平台性能优异 21-Azul VM和BEA Liquid VM的介绍 P21 - 00:03 9.Apache Harmony VM IBM和intel联合开发开元的JVM,受到同样开源的OpenJDK的压制，Sun坚决不让Harmony获得JCP认证，最终与2011年退役，IBM转而参与开发OpenJDK，没有大规模商用，但是他的java类库被吸纳进Android SDK中 22-Apache Harmony的介绍 P22 - 00:01 10 Microsoft JVM windows xp 之前在windows平台下最好的JVM，后期被抹除 23-Microsoft JVM和TaobaoJVM P23 - 00:04 11 Taobao JVM 基于OpenJDK自己定制的ALIBABA JDK 应用在阿里产品上性能高，硬件严重依赖intel的cpu,损失了兼容性，但是提高了性能 23-Microsoft JVM和TaobaoJVM P23 - 00:13 创新的GCIH（GC invisible heap）技术实现了off-heap,即将生命周期较长的java对象从heap（堆）中移到heap之外，并且GC不唔唔管理GCIH内部的java对象，以此达到降低GC的回收频率和提升GC的回收效率目的 GCIH中的对象还能在多个Java虚拟机进程中实现共享 使用crc32指令实现JVM intrinsic 降低JNT的调用开销 PMU headware和Java profiling tool 和诊断协助功能 针对大数据场景的ZenGC 12 Dalvik VM （不是java虚拟机的虚拟机）google开发应用Android 没有遵循java虚拟机规范 执行文件是dex格式文件，基于寄存器架构 24-Dalvik VM及其他虚拟机的介绍 P24 - 00:01 13.Graal VM（Oracle 新虚拟机）在HotSpot vm基础上增强而成的跨语言全栈虚拟机，可以作为任何语言的运行平台使用，语言包括（Java、Scala、Groovy、Kotlin、C、C++、JavaScript、Ruby、Python、R等） 25-Graal VM的介绍 P25 - 00:03 支持不同语言中混用对方的借口和对象，支持这些语言使用已经编译好的本地库文件 工作原理时间爱那个这些语言的源代码或者源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示，GraalVM 提供Truffle工具集快速构建面向一种新语言的解释器，在运行时还能进行即使编译优化，获得比原生编译器更加优秀的执行效率 如果说HotSpot有一天真的被取代，Graal VM希望最大，但是Java的软件生态没有丝毫变化 第二章 类加载子系统 1.Class Loader SubSystem 类加载子系统 Class Files-&gt;Loading-&gt;Linking-&gt;Initialization 1.1.Loading 区域 （负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识，只负责加载，是否能运行则由执行引擎决定） 28-类的加载过程一：Loading P28 - 00:01 Boolstrap Class Loader 引导类加载器、Extension ClassLoader 扩展类加载器、System ClassLoader 应用类&#x2F;系统类加载器 方法区域（7之前永久代，7之后源空间） 加载方式： 1.从本地系统直接加载 2.通过我网络获取，典型场景：Web Applet 3.从zip压缩包中独去，成为日后jar.war格式的基础 4.运行时计算产生，使用最多的，动态代理技术 5.有其他文件身成 典型场景，jsp应用 6.从专有数据库中提取.class文件，比较少见 7.从加密文件中获取，典型的放class文件被反编译的保护措施 1.1.1 类加载器的分类 JVM支持两种类型的类加载器，分别为引导类加载器（bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader） 这里的自定义类加载器指的是将所有派生于抽象类ClassLoader的类加载器都划分为自定义加载器，不是指有开发人员自定义的类加载器（Extension Class Loader#扩展类加载器、System Class Loader#系统类加载器都属于自定义加载器） BootstrapClassLoader 32-引导类、扩展类、系统类加载… P32 - 00:17 BootstrapClassLoader 由c&#x2F;c++编写，嵌套在jvm内部 只加载java的核心类库 （&#x2F;JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar、resources.jar、或者sun.boot.class.path路径下的内容），用于提供jvm自身需要的类，并不是继承自java.lang.Classloader 没有父加载器，加载扩展类加载器和程序类接载其，并指定为他们的父类，处于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类 ExtensionClassLoader 32-引导类、扩展类、系统类加载… P32 - 03:59 由java编写，由sun.misc.Launcher$ExtClassLoader内部类实现，派生于ClassLoader类，父类加载器为BootstrapClassLoader 启动类加载器，从java.ext.dirs系统属性所指定的目录中加载类库，或从JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext子目录（扩展目录）下加载类库，如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载 AppClassLoader 32-引导类、扩展类、系统类加载… P32 - 05:04 java语言编写，由sun.misc.Launcher$AppClassLoader实现，派生与ClassLoader，父类加载器为扩展类加载器，它负责加载环境变量classpath或者系统属性，java.class.path指定下的类库，该类是程序中的默认加载器，一般来说，java应用的类都是由它来加载完成，通过classLoader#getSystemClassLoader（）方法可以获取到该类 用户自定义类加载器 33-为什么需要用户自定义类加载… P33 - 00:05 一般用不到，可能的情况 隔离加载类、修改加载的方式、扩展加载源、防止源码泄露 步骤 1.继承抽象类java.lang.ClassLoader 实现自己的类加载器 2.在JDK1.2之前，在自定义类加载器之前，总会去继承ClassLoader类并重写loadClass（）方法，从而实现自定义的类加载器，但是在JDK1.2之后，不在建议用户覆盖loadClass()方法，二十建议把自定义的类加载逻辑卸载findClass方法中 3.如果没有太过于负责的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass（）方法及获取字节码流的方式。 双亲委派机制 35-双亲委派机制的工作原理及演示 P35 - 00:00 1.如果一个类的加载器收到类加载请求，它并不会自己先去加载，而是把这个请求委托给父类去执行加载， 2.如果父类加载器还存在其父类加载器，则进一步向上委托，依此递归，请求最终将达到顶层类加载器 3.如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派机制 36-双亲委派机制的优势 P36 - 01:54 双亲委派机制的优势： 1.避免类的重复加载 2.保护程序安全，防止核心api被随意篡改 沙箱安全机制 37-沙箱安全机制 P37 - 00:28 eg：自定义String类，但是在加载自定义的String类的时候会率先使用引导类加载器加载，而引导类加载器在加载过程中，会先加载JDK自带的文件，（rt.jar包中的java\\lang\\String.class）报错信息说没有main方法就是因为加载的rt.jar中的String类，这样保证对java核心源代码的保护，这就是沙箱安全机制 其他： 38-类的主动使用与被动使用等 P38 - 00:14 在JVM中，表示两个class对象是否为同一个类存在两个必要条件： 类的完整类名必须一致，包括包名 加载这个类的ClassLoader（指ClassLoader实例对象）必须相同 换句话说，在jvm中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要他们的ClassLoader实力对象不同，那么这两个类对象也是不相等的 JVM必须知道一个类型是由启动类加载器加载的还是由用户类加载器加载的，如果一个类型是用户类加载器加载的，那么JVM会将这个类的加载器的一个引用作为类型信息的一部分保存在方法区中，当解析一个类的另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的 类的主动使用和被动使用 Java程序对类的使用方式分为，主动使用和被动使用 主动使用，又分为7种情况 1.创建类的实例 2.访问某个类或接口的静态资源，或者对该静态变量赋值 3.调用类的静态方法 4.反射（比如：Class.forName(“xxx.xxx.xxx”)） 5.初始化一个类的子类 6.Java虚拟机启动时被标名为启动类的类 7.JDK7开始提供的动态语言支持：Java.lang.invoke.MethodHandle实例的解析结果，REF_getStatic、Ref_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化 除了以上的七种情况，其他使用java类的方式都被看做是对类的被动使用，都不会导致类的初始化 1.2.Linking 区域 29-类的加载过程二：Linking P29 - 00:01 verify验证 目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，包含在呢个被加载类的正确性，不会危害虚拟机本身 主要有四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证 Prepare准备 为类变量分配内存并设置该类的默认初始值，即零值 这里不包含用final修饰的static,因为final在变异的时候就会分配了，准备阶段会显式初始化 这里不会为实力变量分配初始化，类变量会分配在方法区中，而实力变量是会随着对象一起分配到java堆中 Resolve解析 将常量池内的符号引用转换为直接引用的过程 事实上，解析操作往往会伴随着JVM在执行初始化之后再执行 符号引用就是一族符号来描述所引用的目标，符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中，直接引用就是窒息那个目标的指针，相对片量或一个间接定位到目标的句柄 解析动作主要针对类或接口，字段，类方法，接口方法，方法类型等，对影响量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。 1.3.Initialization 区域 初始化 静态变量显式初始化 30-类的加载过程三：Initialization P30 - 02:00 初始化阶段就是执行类构造器方法()的过程 此方法不需要定义，是有javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来 构造方法中指令按照语句在源文件中出现的顺序执行 ()不同于类的构造器。（构造器是虚拟机视角下的()） 若该类具有父类，JVM会保证子类的()执行前，父类的()已经执行完毕 虚拟机必须保证一个类的()方法在多线程下被同步加锁。 2. Runtime Data Areas 运行时数据区 39-运行时数据区内部结构 P39 - 07:27 2.1 Method Area 方法区 2.2 Heap Area 堆区 多个线程共享 2.3 Stack Area 栈区 每个线程独一份 2.4 PC Registers pc寄存器（程序计数器） 每个线程独一份 2.5 Native Method Stack 本地方法栈 2.6 Metaspace（元数据区域）&#x2F;&#x2F;v8之后才有的之前是永久代 java虚拟机定义了若干中程序运行期间会使用到的运行时数据区，其中有一种会随着虚拟机启动而创建，随着随你及推出而销毁，另一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁， 即：每个线程，独立包括程序计数器，虚拟机栈，本地方法栈;线程间共享：堆，堆外内存、方法区（永久代或者元空间、代码缓存） 3.Execution Engine 执行引擎 3.1Interpreter 解释器 3.2 JIT Compiler 即时编译器 （中间代码生成器、代码优化器、目标代码生成器） 3.3 Garbage Collection GC垃圾回收器 如果自己手写虚拟机 需要考虑 类加载子系统以及执行引擎 1 "},{"title":"Linux实践运维","date":"2023-05-31T04:43:18.000Z","url":"/2023/05/31/linux%E8%BF%90%E7%BB%B4%E5%AE%9E%E8%B7%B5/","tags":[["Linux实践运维","/tags/Linux%E5%AE%9E%E8%B7%B5%E8%BF%90%E7%BB%B4/"]],"categories":[[" ",""]],"content":"常用命令 创建定时任务 定时备份docker 容器里面的mysql1.创建备份脚本 2.创建定时任务执行脚本 给服务器设置固定ip Centos7+防火墙开放端口 windows建立共享文件夹，Linux下如何访问 清理docker占用空间 将指定目录下的所有文件分别打成独立的压缩包 免密ssh登录远程主机1.生成ssh公钥和私钥 2.将公钥传到服务器上 3.完成上述步骤已经可以进行SSH免密登录了，顺便配置一下 服务器别称4.打开～&#x2F;.ssh&#x2F;config文件，如果没有可以自己创建，按照如下格式添加即可 5.测试 ssh 别称名 即可登录SSH免密登录 + inotify-tools文件监听 + Docker 实现自动部署1.SSH配置上面已经有了2.安装inotify-tools 3.添加监听脚本和部署脚本 4.后台静默云监听脚本即可 baloo 断网监听及重启docker服务脚本,挂上定是任务,即可时刻通过网络状态对服务 通过JAVA启动参数配置及docker挂载配置,实现docker内java服务出现爆内存情况时自动重启docker服务1.在Dockerfile中最后执行jar启动命令上添加 -XX:OnOutOfMemoryError和-XX:OnError 用于当出现OutOfMemory或者Error时执行命令 2.在容器启动是挂载docker.sock和docker实现在容器内操作docker Centos内核升级1.更新yum源仓库 批量下载文件到指定目录命令: 解释: "},{"title":"Manjaro安装手册","date":"2023-05-31T04:43:18.000Z","url":"/2023/05/31/manjaro%E5%AE%89%E8%A3%85%E6%89%8B%E5%86%8C/","tags":[["Manjaro安装手册","/tags/Manjaro%E5%AE%89%E8%A3%85%E6%89%8B%E5%86%8C/"]],"categories":[[" ",""]],"content":"1.安装软件出现密钥问题执行以下命令 "},{"title":"内核优化","date":"2023-05-31T04:43:18.000Z","url":"/2023/05/31/%E5%86%85%E6%A0%B8%E4%BC%98%E5%8C%96/","tags":[["内核优化","/tags/%E5%86%85%E6%A0%B8%E4%BC%98%E5%8C%96/"]],"categories":[[" ",""]],"content":"修改系统限制值 内核优化"},{"title":"Centos8同步时间","date":"2023-05-31T04:43:18.000Z","url":"/2023/05/31/%E5%90%8C%E6%AD%A5%E6%97%B6%E9%97%B4/","tags":[["Centos8同步时间","/tags/Centos8%E5%90%8C%E6%AD%A5%E6%97%B6%E9%97%B4/"]],"categories":[[" ",""]],"content":"1.安装chrony系统会默认安装并启动，如果系统不存在则需要安装此工具库。 仓库中直接安装 启动守护进程 时间同步配置 设置时区联网的情况下一般设置时区后会通过网络同步时间 2.配置chrony.conf修改配置加入aliyun pool网络时间，也可以加入多个pool服务器vim &#x2F;etc&#x2F;chrony.conf在默认pool服务器下添加阿里云pool服务器 重新加载配置 3.时间同步执行时间同步命令 4.验证查看时间查看当前系统时间date"},{"title":"服务部署","date":"2023-05-31T04:43:18.000Z","url":"/2023/05/31/%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/","tags":[["服务部署","/tags/%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/"]],"categories":[[" ",""]],"content":"1.修改软件安装源 2.创建系统初始必要目录 3.安装mysqld服务 4.配置mysql服务 5.数据库初始化 6.添加数据库访问账户 7.检查防火墙 8.安装nginx组件 9.安装nginx服务本体 10.配置nginx配置文件 11.安装nginx到系统服务 12.启动nginx服务并添加开启启动 13.安装docker服务 14.安装docker到系统服务 15.配置docker仓库镜像 16.添加docker启动服务到系统并设置开机启动 17.安装redis服务 这个需要从外网拉，所以速度会慢一些"},{"title":"Git常用命令","date":"2023-05-31T04:36:25.000Z","url":"/2023/05/31/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","tags":[["git,ssh","/tags/git-ssh/"]],"categories":[[" ",""]],"content":"git 配置 .gitignore git常用命令"}]